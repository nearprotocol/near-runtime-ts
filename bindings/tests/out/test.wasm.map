{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/stub.ts","~lib/near-runtime-ts/storage.ts","~lib/near-runtime-ts/collections/index.ts","~lib/util/string.ts","~lib/bignum/utils.ts","~lib/bignum/globals.ts","~lib/near-runtime-ts/contract.ts","~lib/near-runtime-ts/base64.ts","~lib/assemblyscript-json/decoder.ts","~lib/string.ts","assembly/main.ts","assembly/model.ts","assembly/test.ts","~lib/arraybuffer.ts","~lib/util/error.ts","~lib/memory.ts","~lib/util/memory.ts","~lib/typedarray.ts","~lib/util/number.ts","~lib/array.ts","~lib/rt.ts","~lib/assemblyscript-json/encoder.ts","~lib/number.ts","~lib/builtins.ts","~lib/assemblyscript-json/util/index.ts","~lib/near-runtime-ts/logging.ts","~lib/near-runtime-ts/util.ts"],"names":[],"mappings":"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","sourceRoot":"assemblyscript:///","sourceContents":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n\n//  Common block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -16\n// \n//                            GC info                              -12\n// \n//                           runtime id                            -8\n// \n//                          runtime size                           -4\n// \n//                               ...                               ref\n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize; // WASM64 needs adaption\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n//                                 \n//                       Typeinfo#base  [id=0]                    \n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags;\n  /** Base class id or `0` if none. */\n  base: u32;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `Set`. */\n  SET = 1 << 2,\n  /** Type is a `Map`. */\n  MAP = 1 << 3,\n  /** Type is inherently acyclic. */\n  ACYCLIC = 1 << 4,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 5,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 6,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 7,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 8,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 9,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 10,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 11,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 12,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 13,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 14,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 15,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 16,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 17,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 18,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 19,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 20,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 21,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 22\n}\n","import { AL_MASK, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\n\n// @ts-ignore: decorator\n@lazy\nvar startOffset: usize = (__heap_base + AL_MASK) & ~AL_MASK;\n\n// @ts-ignore: decorator\n@lazy\nvar offset: usize = startOffset;\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __alloc(size: usize, id: u32): usize {\n  if (size > BLOCK_MAXSIZE) unreachable();\n  var ptr = offset + BLOCK_OVERHEAD;\n  var newPtr = (ptr + max<usize>(size, 1) + AL_MASK) & ~AL_MASK;\n  var pagesBefore = memory.size();\n  if (newPtr > <usize>pagesBefore << 16) {\n    let pagesNeeded = ((newPtr - ptr + 0xffff) & ~0xffff) >>> 16;\n    let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n    if (memory.grow(pagesWanted) < 0) {\n      if (memory.grow(pagesNeeded) < 0) unreachable(); // out of memory\n    }\n  }\n  offset = newPtr;\n  var block = changetype<BLOCK>(ptr - BLOCK_OVERHEAD);\n  block.rtId = id;\n  block.rtSize = size;\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __realloc(ref: usize, size: usize): usize {\n  var block = changetype<BLOCK>(ref - BLOCK_OVERHEAD);\n  var oldSize = <usize>block.rtSize;\n  if (size > oldSize) {\n    let newRef = __alloc(size, block.rtId);\n    memory.copy(newRef, ref, oldSize);\n    ref = newRef;\n  } else {\n    block.rtSize = size;\n  }\n  return ref;\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nexport function __free(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@unsafe @global\nfunction __reset(): void { // special\n  offset = startOffset;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __retain(ref: usize): usize {\n  return ref;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __release(ref: usize): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ref: usize, cookie: u32): void {\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n}\n",null,null,"export function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  var result = 0;\n  var ptr1 = changetype<usize>(str1) + (index1 << 1);\n  var ptr2 = changetype<usize>(str2) + (index2 << 1);\n  while (len && !(result = <i32>load<u16>(ptr1) - <i32>load<u16>(ptr2))) {\n    --len, ptr1 += 2, ptr2 += 2;\n  }\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  x = 0x78,\n  z = 0x7A\n}\n\nexport function isSpace(c: i32): bool {\n  if (c <= 0xFF) {\n    switch (c) {\n      case 0x09: // <TAB>\n      case 0x0A: // <LF>\n      case 0x0B: // <VT>\n      case 0x0C: // <FF>\n      case 0x0D: // <CR>\n      case 0x20: // <SP>\n      case 0xA0: return true; // <NBSP>\n    }\n    return false;\n  }\n  if (c >= 0x2000 && c <= 0x200A) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  var len: i32 = str.length;\n  if (!len) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  var ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  var code = <i32>load<u16>(ptr);\n\n  // determine sign\n  // @ts-ignore: cast\n  var sign: T = 1;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <i32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <i32>load<u16>(ptr += 2);\n    // @ts-ignore: type\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) {\n      // @ts-ignore: cast\n      if (isFloat<T>()) return <T>NaN;\n      // @ts-ignore: cast\n      return <T>0;\n    }\n    code = <i32>load<u16>(ptr += 2);\n  }\n\n  // determine radix\n  if (!radix) {\n    if (code == CharCode._0 && len > 2) {\n      switch (<i32>load<u16>(ptr + 2)) {\n        case CharCode.B:\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.O:\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.X:\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n        default: radix = 10;\n      }\n    } else radix = 10;\n  } else if (radix < 2 || radix > 36) {\n    // @ts-ignore: cast\n    if (isFloat<T>()) return <T>NaN;\n    // @ts-ignore: cast\n    return <T>0;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  var num: T = 0;\n  while (len--) {\n    code = <i32>load<u16>(ptr);\n    if (code >= CharCode._0 && code <= CharCode._9) {\n      code -= CharCode._0;\n    } else if (code >= CharCode.A && code <= CharCode.Z) {\n      code -= CharCode.A - 10;\n    } else if (code >= CharCode.a && code <= CharCode.z) {\n      code -= CharCode.a - 10;\n    } else break;\n    if (code >= radix) break;\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\n// FIXME: naive implementation\nexport function strtod(str: string): f64 {\n  var len: i32 = str.length;\n  if (!len) return NaN;\n\n  var ptr = changetype<usize>(str);\n  var code = <i32>load<u16>(ptr);\n\n  // determine sign\n  var sign = 1.0;\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <i32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2);\n    sign = -1.0;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <i32>load<u16>(ptr += 2);\n  }\n\n  // calculate value\n  var num = 0.0;\n  while (len--) {\n    code = <i32>load<u16>(ptr);\n    if (code == CharCode.DOT) {\n      ptr += 2;\n      let fac = 0.1; // precision :(\n      while (len--) {\n        code = <i32>load<u16>(ptr);\n        if (code == CharCode.E || code == CharCode.e) {\n          assert(false); // TODO\n        }\n        code -= CharCode._0;\n        if (<u32>code > 9) break;\n        num += <f64>code * fac;\n        fac *= 0.1;\n        ptr += 2;\n      }\n      break;\n    }\n    code -= CharCode._0;\n    if (<u32>code >= 10) break;\n    num = num * 10 + code;\n    ptr += 2;\n  }\n  return sign * num;\n}\n",null,null,null,null,null,"/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace } from \"./util/string\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\nimport { idof } from \"./builtins\";\n\n@sealed export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = BLOCK_MAXSIZE >>> alignof<u16>();\n\n  static fromCharCode(unit: i32, surr: i32 = -1): string {\n    var hasSur = surr > 0;\n    var out = __alloc(2 << i32(hasSur), idof<string>());\n    store<u16>(out, <u16>unit);\n    if (hasSur) store<u16>(out, <u16>surr, 2);\n    return changetype<string>(out); // retains\n  }\n\n  static fromCodePoint(code: i32): string {\n    assert(<u32>code <= 0x10FFFF);\n    var hasSur = code > 0xFFFF;\n    var out = __alloc(2 << i32(hasSur), idof<string>());\n    if (!hasSur) {\n      store<u16>(out, <u16>code);\n    } else {\n      code -= 0x10000;\n      let hi: u32 = (code >>> 10) + 0xD800;\n      let lo: u32 = (code & 0x3FF) + 0xDC00;\n      store<u32>(out, (hi << 16) | lo);\n    }\n    return changetype<string>(out); // retains\n  }\n\n  get length(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize >> 1;\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    var out = __alloc(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (undefined)\n    var first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if (first < 0xD800 || first > 0xDBFF || pos + 1 == this.length) return first;\n    var second = <i32>load<u16>(changetype<usize>(this) + ((<usize>pos + 1) << 1));\n    if (second < 0xDC00 || second > 0xDFFF) return first;\n    return ((first - 0xD800) << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return select<String>(left, changetype<String>(\"null\"), left !== null).concat(right);\n  }\n\n  concat(other: String): String {\n    if (other === null) other = changetype<String>(\"null\");\n    var thisSize: isize = this.length << 1;\n    var otherSize: isize = other.length << 1;\n    var outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    var out = changetype<String>(__alloc(outSize, idof<String>())); // retains\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    if (search === null) return false;\n    end = min(max(end, 0), this.length);\n    var searchLength = <isize>search.length;\n    var searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (left === right) return true;\n    if (left === null || right === null) return false;\n    var leftLength = left.length;\n    if (leftLength != right.length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return str === null || !str.length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String | null, right: String | null): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    var rightLength = right.length;\n    if (!leftLength)  return false;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) > 0;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (left === right || left === null || right === null) return false;\n    var leftLength  = left.length;\n    var rightLength = right.length;\n    if (!rightLength) return false;\n    if (!leftLength)  return true;\n    // @ts-ignore: string <-> String\n    return compareImpl(left, 0, right, 0, min(leftLength, rightLength)) < 0;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    var len = <isize>this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    var searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    var len = this.length;\n    if (!len) return -1;\n    var searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    if (search === null) search = changetype<String>(\"null\");\n    var len = <isize>this.length;\n    var searchStart = min(max(<isize>start, 0), len);\n    var searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    var intStart: isize = start;\n    var end: isize = length;\n    var size: isize = this.length;\n    if (intStart < 0) intStart = max(size + intStart, 0);\n    var resultLength = min(max(end, 0), size - intStart);\n    if (resultLength <= 0) return changetype<String>(\"\");\n    var out = __alloc(resultLength << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + intStart, resultLength);\n    return changetype<String>(out); // retains\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len: isize = this.length;\n    var finalStart = min<isize>(max(start, 0), len);\n    var finalEnd = min<isize>(max(end, 0), len);\n    var fromPos = min<isize>(finalStart, finalEnd) << 1;\n    var toPos = max<isize>(finalStart, finalEnd) << 1;\n    len = toPos - fromPos;\n    if (!len) return changetype<String>(\"\");\n    if (!fromPos && toPos == this.length << 1) return this;\n    var out = __alloc(len, idof<String>());\n    memory.copy(out, changetype<usize>(this) + fromPos, len);\n    return changetype<String>(out); // retains\n  }\n\n  trim(): String {\n    var length = this.length;\n    var size: usize = length << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == length << 1) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    var size = <usize>this.length << 1;\n    var offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this) + offset, size);\n    return changetype<String>(out); // retains\n  }\n\n  trimEnd(): String {\n    var originalSize = <usize>this.length << 1;\n    var size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    var out = __alloc(size, idof<String>());\n    memory.copy(out, changetype<usize>(this), size);\n    return changetype<String>(out); // retains\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var prependSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(out, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out, changetype<usize>(pad), prependSize);\n    }\n    memory.copy(out + prependSize, changetype<usize>(this), thisSize);\n    return changetype<String>(out); //  retains\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    var thisSize = <usize>this.length << 1;\n    var targetSize = <usize>length << 1;\n    var padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    var appendSize = targetSize - thisSize;\n    var out = __alloc(targetSize, idof<String>());\n    memory.copy(out, changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(out + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(out + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(out + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return changetype<String>(out); // retains\n  }\n\n  repeat(count: i32 = 0): String {\n    var length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    var out = __alloc((length * count) << 1, idof<String>());\n    memory.repeat(out, changetype<usize>(this), <usize>length << 1, count);\n    return changetype<String>(out); // retains\n  }\n\n  replace(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = __alloc(olen << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this), index << 1);\n        memory.copy(\n          out + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          out + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return changetype<String>(out);\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    var len: usize = this.length;\n    var slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    var rlen: usize = replacement.length;\n    if (!slen) {\n      if (!rlen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = __alloc((len + (len + 1) * rlen) << 1, idof<String>());\n      memory.copy(out, changetype<usize>(replacement), rlen << 1);\n      let offset = rlen;\n      for (let i: usize = 0; i < len; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        offset += rlen;\n      }\n      return changetype<String>(out);\n    }\n    var prev: isize = 0, next: isize = 0;\n    if (slen == rlen) {\n      // Fast path when search and replacement have same length\n      let size = len << 1;\n      let out = __alloc(size, idof<String>());\n      memory.copy(out, changetype<usize>(this), size);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(out + (next << 1), changetype<usize>(replacement), rlen << 1);\n        prev = next + slen;\n      }\n      return changetype<String>(out);\n    }\n    var out: usize = 0, offset: usize = 0, resLen = len;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = __alloc(len << 1, idof<String>());\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let chunk = next - prev;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        out + (offset << 1),\n        changetype<usize>(replacement),\n        rlen << 1\n      );\n      offset += rlen;\n      prev = next + slen;\n    }\n    if (offset) {\n      if (offset > resLen) {\n        let newLength = resLen << 1;\n        out = __realloc(out, newLength << 1);\n        resLen = newLength;\n      }\n      let rest = len - prev;\n      if (rest) {\n        memory.copy(\n          out + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (resLen > rest) out = __realloc(out, rest << 1);\n      return changetype<String>(out);\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    var len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    var out = __alloc(len << 1, idof<String>());\n    memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return changetype<String>(out); // retains\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    if (separator === null) return <String[]>[this];\n    var length: isize = this.length;\n    var sepLen: isize = separator.length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>()));  // retains\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = __allocArray(length, alignof<String>(), idof<Array<String>>());\n      let resultStart = changetype<ArrayBufferView>(result).dataStart;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = __alloc(2, idof<String>());\n        store<u16>(charStr, load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), charStr); // result[i] = charStr\n        if (isManaged<String>()) __retain(charStr);\n      }\n      return changetype<Array<String>>(result); // retains\n    } else if (!length) {\n      let result = __allocArray(1, alignof<String>(), idof<Array<String>>());\n      store<usize>(changetype<ArrayBufferView>(result).dataStart, changetype<usize>(\"\")); // static \"\"\n      return changetype<Array<String>>(result); // retains\n    }\n    var result = changetype<Array<String>>(__allocArray(0, alignof<String>(), idof<Array<String>>())); // retains\n    var end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(separator, start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = __alloc(<usize>len << 1, idof<String>());\n        memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(changetype<String>(out));\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return changetype<Array<String>>(result); // retains\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return changetype<Array<String>>(result); // retains\n    }\n    var len = length - start;\n    if (len > 0) {\n      let out = __alloc(<usize>len << 1, idof<String>());\n      memory.copy(out, changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(changetype<String>(out)); // retains\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return changetype<Array<String>>(result); // retains\n    // releases result\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      var strOff = changetype<usize>(str);\n      var strEnd = strOff + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var bufLen = nullTerminated ? 1 : 0;\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          if (nullTerminated && !c1) break;\n          bufLen += 1; strOff += 2;\n        } else if (c1 < 2048) {\n          bufLen += 2; strOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              strOff += 4; bufLen += 4;\n              continue;\n            }\n          }\n          strOff += 2; bufLen += 3;\n        }\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false): ArrayBuffer {\n      var strOff = changetype<usize>(str);\n      var strEnd = changetype<usize>(str) + <usize>changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var buf = __alloc(UTF8.byteLength(str, nullTerminated), idof<ArrayBuffer>());\n      var bufOff = buf;\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          if (nullTerminated && !c1) break;\n          store<u8>(bufOff, c1);\n          bufOff += 1; strOff += 2;\n        } else if (c1 < 2048) {\n          store<u8>(bufOff, c1 >> 6      | 192);\n          store<u8>(bufOff, c1      & 63 | 128, 1);\n          bufOff += 2; strOff += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            let c2 = <u32>load<u16>(strOff, 2);\n            if ((c2 & 0xFC00) == 0xDC00) {\n              c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n              store<u8>(bufOff, c1 >> 18      | 240);\n              store<u8>(bufOff, c1 >> 12 & 63 | 128, 1);\n              store<u8>(bufOff, c1 >> 6  & 63 | 128, 2);\n              store<u8>(bufOff, c1       & 63 | 128, 3);\n              strOff += 4; bufOff += 4;\n              continue;\n            }\n          }\n          store<u8>(bufOff, c1 >> 12      | 224);\n          store<u8>(bufOff, c1 >> 6  & 63 | 128, 1);\n          store<u8>(bufOff, c1       & 63 | 128, 2);\n          strOff += 2; bufOff += 3;\n        }\n      }\n      if (nullTerminated) {\n        assert(strOff <= strEnd);\n        buf = __realloc(buf, bufOff - buf + 1);\n        store<u8>(bufOff, 0);\n      } else {\n        assert(strOff == strEnd);\n      }\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): string {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): string {\n      var bufOff = buf;\n      var bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      var str = __alloc(len << 1, idof<string>()); // max is one u16 char per u8 byte\n      var strOff = str;\n      while (bufOff < bufEnd) {\n        let cp = <u32>load<u8>(bufOff++);\n        if (cp < 128) {\n          if (nullTerminated && !cp) break;\n          store<u16>(strOff, cp);\n          strOff += 2;\n        } else if (cp > 191 && cp < 224) {\n          if (bufEnd - bufOff < 1) break;\n          store<u16>(strOff, (cp & 31) << 6 | load<u8>(bufOff++) & 63);\n          strOff += 2;\n        } else if (cp > 239 && cp < 365) {\n          if (bufEnd - bufOff < 3) break;\n          cp = (\n            (cp                  &  7) << 18 |\n            (load<u8>(bufOff)    & 63) << 12 |\n            (load<u8>(bufOff, 1) & 63) << 6  |\n             load<u8>(bufOff, 2) & 63\n          ) - 0x10000;\n          bufOff += 3;\n          store<u16>(strOff, 0xD800 + (cp >> 10));\n          store<u16>(strOff, 0xDC00 + (cp & 1023), 2);\n          strOff += 4;\n        } else {\n          if (bufEnd - bufOff < 2) break;\n          store<u16>(strOff,\n            (cp                  & 15) << 12 |\n            (load<u8>(bufOff)    & 63) << 6  |\n             load<u8>(bufOff, 1) & 63\n          );\n          bufOff += 2; strOff += 2;\n        }\n      }\n      return changetype<string>(__realloc(str, strOff - str)); // retains\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      var size = changetype<BLOCK>(changetype<usize>(str) - BLOCK_OVERHEAD).rtSize;\n      var buf = __alloc(size, idof<ArrayBuffer>());\n      memory.copy(buf, changetype<usize>(str), <usize>size);\n      return changetype<ArrayBuffer>(buf); // retains\n    }\n\n    export function decode(buf: ArrayBuffer): string {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): string {\n      var str = __alloc(len &= ~1, idof<string>());\n      memory.copy(str, buf, len);\n      return changetype<string>(str); // retains\n    }\n  }\n}\n","//@nearfile\n// These imports need to be copied properly\nimport { storage, context, ContractPromise, logging, util } from \"near-runtime-ts\";\nimport { FooBar, ContainerClass, AnotherContainerClass } from \"./model\";\nimport { PromiseArgs, MyCallbackResult, MyContractPromiseResult } from \"./model\";\n\nexport function doNothing(): void {\n\n}\n\nexport function add(x: i32, y: i32): i32 {\n    return x + y;\n}\n\nexport function rewrapFoobar(container: ContainerClass): AnotherContainerClass {\n    let result = new AnotherContainerClass();\n    result.foobars = [[<FooBar>container.foobar]];\n    return result;\n}\n\nexport function unwrapFoobar(container: AnotherContainerClass): FooBar {\n    return <FooBar>container.foobars[0][0];\n}\n\nexport function getStringArrayLength(arr: string[]): i32 {\n    let length: i32 = arr.length;\n    //@ts-ignore\n    logging.log(\"getStringArrayLength: \" + length.toString());\n    return arr.length;\n}\n\nexport function convertFoobars(foobars: Array<FooBar>): Array<ContainerClass> {\n    return foobars.map<ContainerClass>(foobar => ({ foobar }));\n}\n\nexport function callbackWithName(args: PromiseArgs): MyCallbackResult {\n    let contractResults = ContractPromise.getResults();\n    let allRes = new Array<MyContractPromiseResult>(contractResults.length);\n    for (let i = 0; i < contractResults.length; ++i) {\n        allRes[i] = new MyContractPromiseResult();\n        allRes[i].ok = contractResults[i].success;\n        if (allRes[i].ok && contractResults[i].buffer != null && contractResults[i].buffer!.length > 0) {\n            allRes[i].r = MyCallbackResult.decode(contractResults[i].buffer!);\n        }\n    }\n    let result: MyCallbackResult = {\n        rs: allRes,\n        n: context.contractName,\n    }\n    let bytes = result.encode();\n    storage.setBytes(\"lastResult\", bytes);\n    return result;\n}\n","//@nearfile out\n// import { u128 as _u128 } from 'bignum';\n\nimport {logging} from \"near-runtime-ts\";\n// export class u128 extends _u128 {}\n\n\nexport class FooBar {\n    foo: i32 = 0;\n    bar: u32 = 1;\n    u64Val: u64 = 64;\n    i64Val: i64 = -64;\n    flag: bool;\n    baz: string = \"123\";\n    uint8array: Uint8Array;\n    arr: Array<Array<string>>;\n    u32Arr: u32[];\n    i32Arr: i32[];\n    // u128Val: u128;\n    uint8arrays: Array<Uint8Array>;\n    // TODO: Fix u64 arrays\n    // u64Arr: u64[];\n}\n\nexport class ContainerClass {\n    foobar: FooBar\n}\n\nexport class AnotherContainerClass {\n    foobars: Array<Array<FooBar>>\n}\n\nexport class PromiseArgs {\n    receiver: string;\n    methodName: string;\n    args: PromiseArgs;\n    balance: i32;\n    callback: string;\n    callbackArgs: PromiseArgs;\n    callbackBalance: i32;\n}\n\nexport class MyContractPromiseResult {\n    ok: bool;\n    r: MyCallbackResult;\n}\n\nexport class MyCallbackResult {\n    rs: MyContractPromiseResult[];\n    n: string;\n}\n\nexport class Generic<T> {\n    value: T;\n}","import * as main from \"./main\";\nimport * as model from \"./model\";\nimport { base64 } from \"near-runtime-ts\";\nimport { FooBar } from \"./model\";\n// import { u128 } from \"bignum\";\n\n//@ts-ignore\n@external(\"env\", \"log\")\ndeclare function log(str: string): void;\n\nexport function runTest(): void {\n    let original = new FooBar();\n    original.foo = 321;\n    original.bar = 123;\n    original.flag = true;\n    original.baz = \"foo\";\n    original.uint8array = base64.decode(\"aGVsbG8sIHdvcmxkIQ==\");\n    // original.u128Val = new u128(128);\n    original.uint8arrays = Array.create<Uint8Array>(2);\n    original.uint8arrays[0] = base64.decode(\"aGVsbG8sIHdvcmxkIQ==\");\n    original.uint8arrays[1] = base64.decode(\"aGVsbG8sIHdvcmxkIQ==\");\n    //@ts-ignore\n    let encoded = original.encode().serialize();\n    //@ts-ignore\n    let decoded = FooBar.decode(encoded);\n\n    assert(original.foo == decoded.foo);\n    assert(original.bar == decoded.bar);\n}\n\nexport function convertFoobars(): void {\n    //@ts-ignore will be converted when parsed\n    main.convertFoobars();\n}\n\nexport function getStringArrayLength(): void {\n    //@ts-ignore will be converted when parsed\n    main.getStringArrayLength();\n}\n\nexport function rewrapFoobar(): void {\n    //@ts-ignore will be converted when parsed\n    main.rewrapFoobar();\n}\n\nexport function unwrapFoobar(): void {\n    //@ts-ignore will be converted when parsed\n    main.unwrapFoobar();\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK, BLOCK_MAXSIZE, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  @unsafe data: ArrayBuffer;\n  @unsafe dataStart: usize;\n  @unsafe dataLength: u32;\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(length = length << alignLog2, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    this.data = changetype<ArrayBuffer>(buffer); // retains\n    this.dataStart = buffer;\n    this.dataLength = length;\n  }\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.data));\n  }\n\n  get byteLength(): i32 {\n    return this.dataLength;\n  }\n\n  get length(): i32 {\n    ERROR(\"missing implementation: subclasses must implement ArrayBufferView#length\");\n    return unreachable();\n  }\n}\n\n@sealed export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (value) {\n      if (value instanceof Int8Array) return true;\n      if (value instanceof Uint8Array) return true;\n      if (value instanceof Uint8ClampedArray) return true;\n      if (value instanceof Int16Array) return true;\n      if (value instanceof Uint16Array) return true;\n      if (value instanceof Int32Array) return true;\n      if (value instanceof Uint32Array) return true;\n      if (value instanceof Int64Array) return true;\n      if (value instanceof Uint64Array) return true;\n      if (value instanceof Float32Array) return true;\n      if (value instanceof Float64Array) return true;\n      if (value instanceof DataView) return true;\n    }\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    var buffer = __alloc(<usize>length, idof<ArrayBuffer>());\n    memory.fill(buffer, 0, <usize>length);\n    return changetype<ArrayBuffer>(buffer); // retains\n  }\n\n  get byteLength(): i32 {\n    return changetype<BLOCK>(changetype<usize>(this) - BLOCK_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    var length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    var outSize = <usize>max(end - begin, 0);\n    var out = __alloc(outSize, idof<ArrayBuffer>());\n    memory.copy(out, changetype<usize>(this) + <usize>begin, outSize);\n    return changetype<ArrayBuffer>(out); // retains\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","// Common error messages for use accross the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n","import { memcmp, memmove, memset } from \"./util/memory\";\nimport { E_NOTIMPLEMENTED } from \"./util/error\";\n\n/** Memory manager interface. */\nexport namespace memory {\n\n  /** Gets the size of the memory in pages. */\n  // @ts-ignore: decorator\n  @builtin\n  export declare function size(): i32;\n\n  /** Grows the memory by the given size in pages and returns the previous size in pages. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function grow(pages: i32): i32;\n\n  /** Fills a section in memory with the specified byte value. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function fill(dst: usize, c: u8, n: usize): void {\n    memset(dst, c, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Copies a section of memory to another. Has move semantics. */\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export function copy(dst: usize, src: usize, n: usize): void {\n    memmove(dst, src, n); // fallback if \"bulk-memory\" isn't enabled\n  }\n\n  /** Initializes a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function init(segmentIndex: u32, srcOffset: usize, dstOffset: usize, n: usize): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Drops a memory segment. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function drop(segmentIndex: u32): void {\n    throw new Error(E_NOTIMPLEMENTED);\n  }\n\n  /** Repeats a section of memory at a specific address. */\n  // @ts-ignore: decorator\n  @unsafe\n  export function repeat(dst: usize, src: usize, srcLength: usize, count: usize): void {\n    var index: usize = 0;\n    var total = srcLength * count;\n    while (index < total) {\n      memory.copy(dst + index, src, srcLength);\n      index += srcLength;\n    }\n  }\n\n  /** Compares a section of memory to another. */\n  // @ts-ignore: decorator\n  @inline\n  export function compare(vl: usize, vr: usize, n: usize): i32 {\n    return memcmp(vl, vr, n);\n  }\n}\n","export function memcpy(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memcpy.c\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    let w: u32, x: u32;\n\n    // copy 1 byte each until src is aligned to 4 bytes\n    while (n && (src & 3)) {\n      store<u8>(dest++, load<u8>(src++));\n      n--;\n    }\n\n    // if dst is aligned to 4 bytes as well, copy 4 bytes each\n    if ((dest & 3) == 0) {\n      while (n >= 16) {\n        store<u32>(dest     , load<u32>(src     ));\n        store<u32>(dest +  4, load<u32>(src +  4));\n        store<u32>(dest +  8, load<u32>(src +  8));\n        store<u32>(dest + 12, load<u32>(src + 12));\n        src += 16; dest += 16; n -= 16;\n      }\n      if (n & 8) {\n        store<u32>(dest    , load<u32>(src    ));\n        store<u32>(dest + 4, load<u32>(src + 4));\n        dest += 8; src += 8;\n      }\n      if (n & 4) {\n        store<u32>(dest, load<u32>(src));\n        dest += 4; src += 4;\n      }\n      if (n & 2) { // drop to 2 bytes each\n        store<u16>(dest, load<u16>(src));\n        dest += 2; src += 2;\n      }\n      if (n & 1) { // drop to 1 byte\n        store<u8>(dest++, load<u8>(src++));\n      }\n      return;\n    }\n\n    // if dst is not aligned to 4 bytes, use alternating shifts to copy 4 bytes each\n    // doing shifts if faster when copying enough bytes (here: 32 or more)\n    if (n >= 32) {\n      switch (dest & 3) {\n        // known to be != 0\n        case 1: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 3;\n          while (n >= 17) {\n            x = load<u32>(src + 1);\n            store<u32>(dest, w >> 24 | x << 8);\n            w = load<u32>(src + 5);\n            store<u32>(dest + 4, x >> 24 | w << 8);\n            x = load<u32>(src + 9);\n            store<u32>(dest + 8, w >> 24 | x << 8);\n            w = load<u32>(src + 13);\n            store<u32>(dest + 12, x >> 24 | w << 8);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 2: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          store<u8>(dest++, load<u8>(src++));\n          n -= 2;\n          while (n >= 18) {\n            x = load<u32>(src + 2);\n            store<u32>(dest, w >> 16 | x << 16);\n            w = load<u32>(src + 6);\n            store<u32>(dest + 4, x >> 16 | w << 16);\n            x = load<u32>(src + 10);\n            store<u32>(dest + 8, w >> 16 | x << 16);\n            w = load<u32>(src + 14);\n            store<u32>(dest + 12, x >> 16 | w << 16);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n        case 3: {\n          w = load<u32>(src);\n          store<u8>(dest++, load<u8>(src++));\n          n -= 1;\n          while (n >= 19) {\n            x = load<u32>(src + 3);\n            store<u32>(dest, w >> 8 | x << 24);\n            w = load<u32>(src + 7);\n            store<u32>(dest + 4, x >> 8 | w << 24);\n            x = load<u32>(src + 11);\n            store<u32>(dest + 8, w >> 8 | x << 24);\n            w = load<u32>(src + 15);\n            store<u32>(dest + 12, x >> 8 | w << 24);\n            src += 16; dest += 16; n -= 16;\n          }\n          break;\n        }\n      }\n    }\n\n    // copy remaining bytes one by one\n    if (n & 16) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 8) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 4) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 2) {\n      store<u8>(dest++, load<u8>(src++));\n      store<u8>(dest++, load<u8>(src++));\n    }\n    if (n & 1) {\n      store<u8>(dest++, load<u8>(src++));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memmove(dest: usize, src: usize, n: usize): void { // see: musl/src/string/memmove.c\n  if (dest === src) return;\n  if (ASC_SHRINK_LEVEL < 1) {\n    if (src + n <= dest || dest + n <= src) {\n      memcpy(dest, src, n);\n      return;\n    }\n  }\n  if (dest < src) {\n    if ((src & 7) == (dest & 7)) {\n      while (dest & 7) {\n        if (!n) return;\n        --n;\n        store<u8>(dest++, load<u8>(src++));\n      }\n      while (n >= 8) {\n        store<u64>(dest, load<u64>(src));\n        n    -= 8;\n        dest += 8;\n        src  += 8;\n      }\n    }\n    while (n) {\n      store<u8>(dest++, load<u8>(src++));\n      --n;\n    }\n  } else {\n    if ((src & 7) == (dest & 7)) {\n      while ((dest + n) & 7) {\n        if (!n) return;\n        store<u8>(dest + --n, load<u8>(src + n));\n      }\n      while (n >= 8) {\n        n -= 8;\n        store<u64>(dest + n, load<u64>(src + n));\n      }\n    }\n    while (n) {\n      store<u8>(dest + --n, load<u8>(src + n));\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memset(dest: usize, c: u8, n: usize): void { // see: musl/src/string/memset\n  if (ASC_SHRINK_LEVEL > 1) {\n    while (n) {\n      store<u8>(dest++, c);\n      --n;\n    }\n  } else {\n    // fill head and tail with minimal branching\n    if (!n) return;\n    store<u8>(dest, c);\n    store<u8>(dest + n - 1, c);\n    if (n <= 2) return;\n\n    store<u8>(dest + 1, c);\n    store<u8>(dest + 2, c);\n    store<u8>(dest + n - 2, c);\n    store<u8>(dest + n - 3, c);\n    if (n <= 6) return;\n    store<u8>(dest + 3, c);\n    store<u8>(dest + n - 4, c);\n    if (n <= 8) return;\n\n    // advance pointer to align it at 4-byte boundary\n    let k: usize = -dest & 3;\n    dest += k;\n    n -= k;\n    n &= -4;\n\n    let c32: u32 = <u32>-1 / 255 * c;\n\n    // fill head/tail up to 28 bytes each in preparation\n    store<u32>(dest, c32);\n    store<u32>(dest + n - 4, c32);\n    if (n <= 8) return;\n    store<u32>(dest + 4, c32);\n    store<u32>(dest + 8, c32);\n    store<u32>(dest + n - 12, c32);\n    store<u32>(dest + n - 8, c32);\n    if (n <= 24) return;\n    store<u32>(dest + 12, c32);\n    store<u32>(dest + 16, c32);\n    store<u32>(dest + 20, c32);\n    store<u32>(dest + 24, c32);\n    store<u32>(dest + n - 28, c32);\n    store<u32>(dest + n - 24, c32);\n    store<u32>(dest + n - 20, c32);\n    store<u32>(dest + n - 16, c32);\n\n    // align to a multiple of 8\n    k = 24 + (dest & 4);\n    dest += k;\n    n -= k;\n\n    // copy 32 bytes each\n    let c64: u64 = <u64>c32 | (<u64>c32 << 32);\n    while (n >= 32) {\n      store<u64>(dest, c64);\n      store<u64>(dest + 8, c64);\n      store<u64>(dest + 16, c64);\n      store<u64>(dest + 24, c64);\n      n -= 32;\n      dest += 32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function memcmp(vl: usize, vr: usize, n: usize): i32 { // see: musl/src/string/memcmp.c\n  if (vl == vr) return 0;\n  while (n != 0 && load<u8>(vl) == load<u8>(vr)) {\n    n--; vl++; vr++;\n  }\n  return n ? <i32>load<u8>(vl) - <i32>load<u8>(vr) : 0;\n}\n","import { COMPARATOR, SORT as SORT_IMPL } from \"./util/sort\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\nexport class Int8Array extends ArrayBufferView {\n  [key: number]: i8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i8>();\n\n  constructor(length: i32) {\n    super(length, alignof<i8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i8 {\n    return load<i8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i8>): void {\n    store<i8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: i8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int8Array, i8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int8Array {\n    return FILL<Int8Array, i8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i8, b: i8) => i32 = COMPARATOR<i8>()): Int8Array {\n    return SORT<Int8Array, i8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int8Array {\n    return SUBARRAY<Int8Array, i8>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i8, index: i32, array: Int8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int8Array, i8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i8, index: i32, self: Int8Array) => i8): Int8Array {\n    return MAP<Int8Array, i8>(this, fn);\n  }\n\n  findIndex(fn: (value: i8, index: i32, self: Int8Array) => bool): i32 {\n    return FIND_INDEX<Int8Array, i8>(this, fn);\n  }\n\n  some(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return SOME<Int8Array, i8>(this, fn);\n  }\n\n  every(fn: (value: i8, index: i32, self: Int8Array) => bool): bool {\n    return EVERY<Int8Array, i8>(this, fn);\n  }\n\n  forEach(fn: (value: i8, index: i32, self: Int8Array) => void): void {\n    FOREACH<Int8Array, i8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i8>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int8Array {\n    return WRAP<Int8Array, i8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8Array extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, value);\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8Array, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8Array {\n    return FILL<Uint8Array, u8>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8Array {\n    return SORT<Uint8Array, u8>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint8Array {\n    return SUBARRAY<Uint8Array, u8>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8Array, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8Array) => u8): Uint8Array {\n    return MAP<Uint8Array, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8Array) => bool): i32 {\n    return FIND_INDEX<Uint8Array, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return SOME<Uint8Array, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8Array) => bool): bool {\n    return EVERY<Uint8Array, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8Array) => void): void {\n    FOREACH<Uint8Array, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8Array {\n    return WRAP<Uint8Array, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint8ClampedArray extends ArrayBufferView {\n  [key: number]: u8;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u8>();\n\n  constructor(length: i32) {\n    super(length, alignof<u8>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength;\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u8 {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u8 {\n    return load<u8>(this.dataStart + <usize>index);\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u8>): void {\n    if (<u32>index >= <u32>this.dataLength) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u8>): void {\n    store<u8>(this.dataStart + <usize>index, ~(<i32>value >> 31) & (((255 - value) >> 31) | value));\n  }\n\n  includes(searchElement: u8, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u8, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u8, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint8ClampedArray, u8>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint8ClampedArray {\n    return FILL<Uint8ClampedArray, u8>(this, value, start, end);\n  }\n\n  sort(fn: (a: u8, b: u8) => i32 = COMPARATOR<u8>()): Uint8ClampedArray {\n    return SORT<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  subarray(start: i32 = 0, end: i32 = 0x7fffffff): Uint8ClampedArray {\n    return SUBARRAY<Uint8ClampedArray, u8>(this, start, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u8, index: i32, array: Uint8ClampedArray) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint8ClampedArray, u8, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u8, index: i32, self: Uint8ClampedArray) => u8): Uint8ClampedArray {\n    return MAP<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  findIndex(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): i32 {\n    return FIND_INDEX<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  some(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return SOME<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  every(fn: (value: u8, index: i32, self: Uint8ClampedArray) => bool): bool {\n    return EVERY<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  forEach(fn: (value: u8, index: i32, self: Uint8ClampedArray) => void): void {\n    FOREACH<Uint8ClampedArray, u8>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u8>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint8ClampedArray {\n    return WRAP<Uint8ClampedArray, u8>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int16Array extends ArrayBufferView {\n  [key: number]: i16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i16>();\n\n  constructor(length: i32) {\n    super(length, alignof<i16>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i16 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i16 {\n    return load<i16>(this.dataStart + (<usize>index << alignof<i16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<i16>): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<i16>): void {\n    store<i16>(this.dataStart + (<usize>index << alignof<i16>()), value);\n  }\n\n  includes(searchElement: i16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int16Array, i16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int16Array {\n    return FILL<Int16Array, i16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i16, b: i16) => i32 = COMPARATOR<i16>()): Int16Array {\n    return SORT<Int16Array, i16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int16Array {\n    return SUBARRAY<Int16Array, i16>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i16, index: i32, array: Int16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int16Array, i16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i16, index: i32, self: Int16Array) => i16): Int16Array {\n    return MAP<Int16Array, i16>(this, fn);\n  }\n\n  findIndex(fn: (value: i16, index: i32, self: Int16Array) => bool): i32 {\n    return FIND_INDEX<Int16Array, i16>(this, fn);\n  }\n\n  some(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return SOME<Int16Array, i16>(this, fn);\n  }\n\n  every(fn: (value: i16, index: i32, self: Int16Array) => bool): bool {\n    return EVERY<Int16Array, i16>(this, fn);\n  }\n\n  forEach(fn: (value: i16, index: i32, self: Int16Array) => void): void {\n    FOREACH<Int16Array, i16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i16>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int16Array {\n    return WRAP<Int16Array, i16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint16Array extends ArrayBufferView {\n  [key: number]: u16;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u16>();\n\n  constructor(length: i32) {\n    super(length, alignof<u16>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u16>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u16 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u16 {\n    return load<u16>(this.dataStart + (<usize>index << alignof<u16>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: native<u16>): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u16>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: native<u16>): void {\n    store<u16>(this.dataStart + (<usize>index << alignof<u16>()), value);\n  }\n\n  includes(searchElement: u16, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u16, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u16, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint16Array, u16>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint16Array {\n    return FILL<Uint16Array, u16>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u16, b: u16) => i32 = COMPARATOR<u16>()): Uint16Array {\n    return SORT<Uint16Array, u16>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint16Array {\n    return SUBARRAY<Uint16Array, u16>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u16, index: i32, array: Uint16Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint16Array, u16, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u16, index: i32, self: Uint16Array) => u16): Uint16Array {\n    return MAP<Uint16Array, u16>(this, fn);\n  }\n\n  findIndex(fn: (value: u16, index: i32, self: Uint16Array) => bool): i32 {\n    return FIND_INDEX<Uint16Array, u16>(this, fn);\n  }\n\n  some(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return SOME<Uint16Array, u16>(this, fn);\n  }\n\n  every(fn: (value: u16, index: i32, self: Uint16Array) => bool): bool {\n    return EVERY<Uint16Array, u16>(this, fn);\n  }\n\n  forEach(fn: (value: u16, index: i32, self: Uint16Array) => void): void {\n    FOREACH<Uint16Array, u16>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u16>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint16Array {\n    return WRAP<Uint16Array, u16>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int32Array extends ArrayBufferView {\n  [key: number]: i32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i32>();\n\n  constructor(length: i32) {\n    super(length, alignof<i32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i32 {\n    return load<i32>(this.dataStart + (<usize>index << alignof<i32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i32): void {\n    store<i32>(this.dataStart + (<usize>index << alignof<i32>()), value);\n  }\n\n  includes(searchElement: i32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int32Array, i32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int32Array {\n    return FILL<Int32Array, i32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i32, b: i32) => i32 = COMPARATOR<i32>()): Int32Array {\n    return SORT<Int32Array, i32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int32Array {\n    return SUBARRAY<Int32Array, i32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i32, index: i32, array: Int32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int32Array, i32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i32, index: i32, self: Int32Array) => i32): Int32Array {\n    return MAP<Int32Array, i32>(this, fn);\n  }\n\n  findIndex(fn: (value: i32, index: i32, self: Int32Array) => bool): i32 {\n    return FIND_INDEX<Int32Array, i32>(this, fn);\n  }\n\n  some(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return SOME<Int32Array, i32>(this, fn);\n  }\n\n  every(fn: (value: i32, index: i32, self: Int32Array) => bool): bool {\n    return EVERY<Int32Array, i32>(this, fn);\n  }\n\n  forEach(fn: (value: i32, index: i32, self: Int32Array) => void): void {\n    FOREACH<Int32Array, i32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i32>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int32Array {\n    return WRAP<Int32Array, i32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint32Array extends ArrayBufferView {\n  [key: number]: u32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u32>();\n\n  constructor(length: i32) {\n    super(length, alignof<u32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u32 {\n    return load<u32>(this.dataStart + (<usize>index << alignof<u32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u32): void {\n    store<u32>(this.dataStart + (<usize>index << alignof<u32>()), value);\n  }\n\n  includes(searchElement: u32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint32Array, u32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint32Array {\n    return FILL<Uint32Array, u32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u32, b: u32) => i32 = COMPARATOR<u32>()): Uint32Array {\n    return SORT<Uint32Array, u32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint32Array {\n    return SUBARRAY<Uint32Array, u32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u32, index: i32, array: Uint32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint32Array, u32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u32, index: i32, self: Uint32Array) => u32): Uint32Array {\n    return MAP<Uint32Array, u32>(this, fn);\n  }\n\n  findIndex(fn: (value: u32, index: i32, self: Uint32Array) => bool): i32 {\n    return FIND_INDEX<Uint32Array, u32>(this, fn);\n  }\n\n  some(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return SOME<Uint32Array, u32>(this, fn);\n  }\n\n  every(fn: (value: u32, index: i32, self: Uint32Array) => bool): bool {\n    return EVERY<Uint32Array, u32>(this, fn);\n  }\n\n  forEach(fn: (value: u32, index: i32, self: Uint32Array) => void): void {\n    FOREACH<Uint32Array, u32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u32>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint32Array {\n    return WRAP<Uint32Array, u32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Int64Array extends ArrayBufferView {\n  [key: number]: i64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<i64>();\n\n  constructor(length: i32) {\n    super(length, alignof<i64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<i64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): i64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): i64 {\n    return load<i64>(this.dataStart + (<usize>index << alignof<i64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: i64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<i64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: i64): void {\n    store<i64>(this.dataStart + (<usize>index << alignof<i64>()), value);\n  }\n\n  includes(searchElement: i64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: i64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: i64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Int64Array, i64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: i64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Int64Array {\n    return FILL<Int64Array, i64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: i64, b: i64) => i32 = COMPARATOR<i64>()): Int64Array {\n    return SORT<Int64Array, i64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Int64Array {\n    return SUBARRAY<Int64Array, i64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: i64, index: i32, array: Int64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Int64Array, i64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: i64, index: i32, self: Int64Array) => i64): Int64Array {\n    return MAP<Int64Array, i64>(this, fn);\n  }\n\n  findIndex(fn: (value: i64, index: i32, self: Int64Array) => bool): i32 {\n    return FIND_INDEX<Int64Array, i64>(this, fn);\n  }\n\n  some(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return SOME<Int64Array, i64>(this, fn);\n  }\n\n  every(fn: (value: i64, index: i32, self: Int64Array) => bool): bool {\n    return EVERY<Int64Array, i64>(this, fn);\n  }\n\n  forEach(fn: (value: i64, index: i32, self: Int64Array) => void): void {\n    FOREACH<Int64Array, i64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, i64>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Int64Array {\n    return WRAP<Int64Array, i64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Uint64Array extends ArrayBufferView {\n  [key: number]: u64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<u64>();\n\n  constructor(length: i32) {\n    super(length, alignof<u64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<u64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): u64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): u64 {\n    return load<u64>(this.dataStart + (<usize>index << alignof<u64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: u64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<u64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: u64): void {\n    store<u64>(this.dataStart + (<usize>index << alignof<u64>()), value);\n  }\n\n  includes(searchElement: u64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: u64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: u64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Uint64Array, u64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: u64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Uint64Array {\n    return FILL<Uint64Array, u64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: u64, b: u64) => i32 = COMPARATOR<u64>()): Uint64Array {\n    return SORT<Uint64Array, u64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Uint64Array {\n    return SUBARRAY<Uint64Array, u64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: u64, index: i32, array: Uint64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Uint64Array, u64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: u64, index: i32, self: Uint64Array) => u64): Uint64Array {\n    return MAP<Uint64Array, u64>(this, fn);\n  }\n\n  findIndex(fn: (value: u64, index: i32, self: Uint64Array) => bool): i32 {\n    return FIND_INDEX<Uint64Array, u64>(this, fn);\n  }\n\n  some(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return SOME<Uint64Array, u64>(this, fn);\n  }\n\n  every(fn: (value: u64, index: i32, self: Uint64Array) => bool): bool {\n    return EVERY<Uint64Array, u64>(this, fn);\n  }\n\n  forEach(fn: (value: u64, index: i32, self: Uint64Array) => void): void {\n    FOREACH<Uint64Array, u64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, u64>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Uint64Array {\n    return WRAP<Uint64Array, u64>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float32Array extends ArrayBufferView {\n  [key: number]: f32;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f32>();\n\n  constructor(length: i32) {\n    super(length, alignof<f32>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f32>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f32 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f32 {\n    return load<f32>(this.dataStart + (<usize>index << alignof<f32>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f32): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f32>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f32): void {\n    store<f32>(this.dataStart + (<usize>index << alignof<f32>()), value);\n  }\n\n  includes(searchElement: f32, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f32, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f32, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float32Array, f32>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f32, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float32Array {\n    return FILL<Float32Array, f32>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f32, b: f32) => i32 = COMPARATOR<f32>()): Float32Array {\n    return SORT<Float32Array, f32>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float32Array {\n    return SUBARRAY<Float32Array, f32>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f32, index: i32, array: Float32Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float32Array, f32, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f32, index: i32, self: Float32Array) => f32): Float32Array {\n    return MAP<Float32Array, f32>(this, fn);\n  }\n\n  findIndex(fn: (value: f32, index: i32, self: Float32Array) => bool): i32 {\n    return FIND_INDEX<Float32Array, f32>(this, fn);\n  }\n\n  some(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return SOME<Float32Array, f32>(this, fn);\n  }\n\n  every(fn: (value: f32, index: i32, self: Float32Array) => bool): bool {\n    return EVERY<Float32Array, f32>(this, fn);\n  }\n\n  forEach(fn: (value: f32, index: i32, self: Float32Array) => void): void {\n    FOREACH<Float32Array, f32>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f32>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float32Array {\n    return WRAP<Float32Array, f32>(buffer, byteOffset, length);\n  }\n}\n\nexport class Float64Array extends ArrayBufferView {\n  [key: number]: f64;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly BYTES_PER_ELEMENT: usize = sizeof<f64>();\n\n  constructor(length: i32) {\n    super(length, alignof<f64>());\n  }\n\n  get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.byteLength >>> alignof<f64>();\n  }\n\n  @operator(\"[]\")\n  private __get(index: i32): f64 {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @unsafe @operator(\"{}\")\n  private __uget(index: i32): f64 {\n    return load<f64>(this.dataStart + (<usize>index << alignof<f64>()));\n  }\n\n  @operator(\"[]=\")\n  private __set(index: i32, value: f64): void {\n    if (<u32>index >= <u32>this.dataLength >>> alignof<f64>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  @unsafe @operator(\"{}=\")\n  private __uset(index: i32, value: f64): void {\n    store<f64>(this.dataStart + (<usize>index << alignof<f64>()), value);\n  }\n\n  includes(searchElement: f64, fromIndex: i32 = 0): bool {\n    return INCLUDES<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  indexOf(searchElement: f64, fromIndex: i32 = 0): i32 {\n    return INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  lastIndexOf(searchElement: f64, fromIndex: i32 = this.length): i32 {\n    return LAST_INDEX_OF<Float64Array, f64>(this, searchElement, fromIndex);\n  }\n\n  fill(value: f64, start: i32 = 0, end: i32 = i32.MAX_VALUE): Float64Array {\n    return FILL<Float64Array, f64>(this, value, start, end);\n  }\n\n  sort(comparator: (a: f64, b: f64) => i32 = COMPARATOR<f64>()): Float64Array {\n    return SORT<Float64Array, f64>(this, comparator);\n  }\n\n  subarray(begin: i32 = 0, end: i32 = 0x7fffffff): Float64Array {\n    return SUBARRAY<Float64Array, f64>(this, begin, end);\n  }\n\n  reduce<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  reduceRight<T>(\n    fn: (accumulator: T, value: f64, index: i32, array: Float64Array) => T,\n    initialValue: T,\n  ): T {\n    return REDUCE_RIGHT<Float64Array, f64, T>(this, fn, initialValue);\n  }\n\n  map(fn: (value: f64, index: i32, self: Float64Array) => f64): Float64Array {\n    return MAP<Float64Array, f64>(this, fn);\n  }\n\n  findIndex(fn: (value: f64, index: i32, self: Float64Array) => bool): i32 {\n    return FIND_INDEX<Float64Array, f64>(this, fn);\n  }\n\n  some(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return SOME<Float64Array, f64>(this, fn);\n  }\n\n  every(fn: (value: f64, index: i32, self: Float64Array) => bool): bool {\n    return EVERY<Float64Array, f64>(this, fn);\n  }\n\n  forEach(fn: (value: f64, index: i32, self: Float64Array) => void): void {\n    FOREACH<Float64Array, f64>(this, fn);\n  }\n\n  reverse(): this {\n    return REVERSE<this, f64>(this);\n  }\n\n  static wrap(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): Float64Array {\n    return WRAP<Float64Array, f64>(buffer, byteOffset, length);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FILL<TArray extends ArrayBufferView, T extends number>(\n  array: TArray,\n  value: native<T>,\n  start: i32,\n  end: i32\n): TArray {\n  var dataStart = array.dataStart;\n  var length = array.length;\n  start = start < 0 ? max(length + start, 0) : min(start, length);\n  end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n  if (sizeof<T>() == 1) {\n    if (start < end) memory.fill(dataStart + <usize>start, <u8>value, <usize>(end - start));\n  } else {\n    for (; start < end; ++start) {\n      store<T>(dataStart + (<usize>start << alignof<T>()), value);\n    }\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SORT<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  comparator: (a: T, b: T) => i32\n): TArray {\n  var length = array.length;\n  if (length <= 1) return array;\n  var base = array.dataStart;\n  if (length == 2) {\n    let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n    let b: T = load<T>(base); // b = arr[0]\n    if (comparator(a, b) < 0) {\n      store<T>(base, b, sizeof<T>()); // arr[1] = b\n      store<T>(base, a); // arr[0] = a\n    }\n    return array;\n  }\n  SORT_IMPL<T>(base, length, comparator);\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SUBARRAY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  begin: i32,\n  end: i32\n): TArray {\n  var len = <i32>array.length;\n  begin = begin < 0 ? max(len + begin, 0) : min(begin, len);\n  end   = end   < 0 ? max(len + end,   0) : min(end,   len);\n  end   = max(end, begin);\n  var out = changetype<TArray>(__alloc(offsetof<TArray>(), idof<TArray>())); // retains\n  out.data = array.data; // retains\n  out.dataStart = array.dataStart + (<usize>begin << alignof<T>());\n  out.dataLength = (end - begin) << alignof<T>();\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REDUCE_RIGHT<TArray extends ArrayBufferView, T, TRet>(\n  array: TArray,\n  fn: (accumulator: TRet, value: T, index: i32, array: TArray) => TRet,\n  initialValue: TRet\n): TRet {\n  var dataStart = array.dataStart;\n  for (let i = array.length - 1; i >= 0; i--) {\n    initialValue = fn(initialValue, load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n  return initialValue;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction MAP<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, self: TArray) => T,\n): TArray {\n  var length = array.length;\n  var dataStart = array.dataStart;\n  var out = instantiate<TArray>(length);\n  var outDataStart = out.dataStart;\n  for (let i = 0; i < length; i++) {\n    store<T>(\n      outDataStart + (<usize>i << alignof<T>()),\n      fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)\n    );\n  }\n  return out;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FIND_INDEX<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): i32 {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return i;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INCLUDES<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): bool {\n  return INDEX_OF<TArray, T>(array, searchElement, fromIndex) >= 0;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0 || index >= length) return -1;\n  if (index < 0) index = max(length + index, 0);\n  var dataStart = array.dataStart;\n  while (index < length) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    ++index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction LAST_INDEX_OF<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  searchElement: T,\n  fromIndex: i32,\n): i32 {\n  var index: isize = fromIndex;\n  var length: isize = array.length;\n  if (length == 0) return -1;\n  if (index < 0) index = length + index; // no need to clamp\n  else if (index >= length) index = length - 1;\n  var dataStart = array.dataStart;\n  while (index >= 0) {\n    if (load<T>(dataStart + (index << alignof<T>())) == searchElement) return <i32>index;\n    --index;\n  }\n  return -1;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction SOME<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) return true;\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction EVERY<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => bool,\n): bool {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    if (fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array)) continue;\n    return false;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction FOREACH<TArray extends ArrayBufferView, T>(\n  array: TArray,\n  fn: (value: T, index: i32, array: TArray) => void,\n): void {\n  var dataStart = array.dataStart;\n  for (let i = 0, k = array.length; i < k; i++) {\n    fn(load<T>(dataStart + (<usize>i << alignof<T>())), i, array);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction REVERSE<TArray extends ArrayBufferView, T>(array: TArray): TArray {\n  var dataStart = array.dataStart;\n  for (let front: usize = 0, back: usize = array.length - 1; front < back; ++front, --back) {\n    let frontPtr = dataStart + (front << alignof<T>());\n    let backPtr = dataStart + (back << alignof<T>());\n    let temp = load<T>(frontPtr);\n    store<T>(frontPtr, load<T>(backPtr));\n    store<T>(backPtr, temp);\n  }\n  return array;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction WRAP<TArray extends ArrayBufferView, T>(buffer: ArrayBuffer, byteOffset: i32 = 0, length: i32 = -1): TArray {\n  var bufferByteLength = buffer.byteLength;\n  if (<u32>byteOffset >= <u32>bufferByteLength) {\n    throw new RangeError(E_INDEXOUTOFRANGE);\n  }\n  var byteLength: i32;\n  if (length < 0) {\n    if (length == -1) {\n      const mask = <i32>(1 << alignof<T>() - 1);\n      if (buffer.byteLength & mask) {\n        throw new RangeError(E_INVALIDLENGTH);\n      } else {\n        byteLength = buffer.byteLength;\n      }\n    } else {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n  } else {\n    byteLength = length << alignof<T>();\n  }\n  if (byteOffset + byteLength > buffer.byteLength) {\n    throw new RangeError(E_INVALIDLENGTH);\n  }\n  var out = changetype<TArray>(__alloc(offsetof<TArray>(), idof<TArray>()));\n  out.data = buffer;\n  out.dataLength = byteLength;\n  out.dataStart = changetype<usize>(buffer) + <usize>byteOffset;\n  return out;\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\nimport { ArrayBufferView } from \"../arraybuffer\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline\nconst POWERS10: u32[] = [\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n];\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline\nconst DIGITS: u32[] = [\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n];\n\n// @ts-ignore: decorator\n@lazy @inline\nconst EXP_POWERS: i16[] = [\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n];\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline\nconst FRC_POWERS: u64[] = [\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n];\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return select<u32>(1, 2, value < 10);\n    } else {\n      let m = select<u32>(4, 5, value < 10000);\n      return select<u32>(3, m, value < 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return select<u32>(6, 7, value < 1000000);\n    } else {\n      let m = select<u32>(9, 10, value < 1000000000);\n      return select<u32>(8, m, value < 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return select<u32>(11, 12, value < 100000000000);\n    } else {\n      let m = select<u32>(14, 15, value < 100000000000000);\n      return select<u32>(13, m, value < 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return select<u32>(16, 17, value < 10000000000000000);\n    } else {\n      let m = select<u32>(19, 20, value < 10000000000000000000);\n      return select<u32>(18, m, value < 1000000000000000000);\n    }\n  }\n}\n\nfunction utoa32_lut(buffer: usize, num: u32, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(lut + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_lut(buffer: usize, num: u64, offset: usize): void {\n  var lut = changetype<ArrayBufferView>(DIGITS).dataStart;\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(lut + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(lut + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(lut + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(lut + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset -= 1;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_core(buffer: usize, num: u32, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa32_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa64_core(buffer: usize, num: u64, offset: u32): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_simple(buffer, num, offset);\n  } else {\n    utoa64_lut(buffer, num, offset);\n  }\n}\n\nexport function utoa32(value: u32): String {\n  if (!value) return \"0\";\n\n  var decimals = decimalCount32(value);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  return changetype<String>(out); // retains\n}\n\nexport function itoa32(value: i32): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var decimals = decimalCount32(value) + u32(sign);\n  var out = __alloc(decimals << 1, idof<String>());\n\n  utoa32_core(out, value, decimals);\n  if (sign) store<u16>(out, CharCode.MINUS);\n  return changetype<String>(out); // retains\n}\n\nexport function utoa64(value: u64): String {\n  if (!value) return \"0\";\n\n  var out: usize;\n  if (value <= u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  return changetype<String>(out); // retains\n}\n\nexport function itoa64(value: i64): String {\n  if (!value) return \"0\";\n\n  var sign = value < 0;\n  if (sign) value = -value;\n\n  var out: usize;\n  if (<u64>value <= <u64>u32.MAX_VALUE) {\n    let val32    = <u32>value;\n    let decimals = decimalCount32(val32) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa32_core(out, val32, decimals);\n  } else {\n    let decimals = decimalCount64(value) + u32(sign);\n    out = __alloc(decimals << 1, idof<String>());\n    utoa64_core(out, value, decimals);\n  }\n  if (sign) store<u16>(out, CharCode.MINUS);\n\n  return changetype<String>(out); // retains\n}\n\nexport function itoa<T extends number>(value: T): String {\n  if (!isInteger<T>()) ERROR(\"integer type expected\");\n  if (isSigned<T>()) {\n    if (sizeof<T>() <= 4) {\n      return itoa32(<i32>value);\n    } else {\n      return itoa64(<i64>value);\n    }\n  } else {\n    if (sizeof<T>() <= 4) {\n      return utoa32(<u32>value);\n    } else {\n      return utoa64(<u64>value);\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy\nvar _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// var _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_plus:  u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy\nvar _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  var u0 = u & 0xFFFFFFFF;\n  var v0 = v & 0xFFFFFFFF;\n\n  var u1 = u >> 32;\n  var v1 = v >> 32;\n\n  var l = u0 * v0;\n  var t = u1 * v0 + (l >> 32);\n  var w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32): void {\n  var frc = (f << 1) + 1;\n  var exp = e - 1;\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var m = 1 + i32(f == 0x0010000000000000);\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  var lastp = buffer + ((len - 1) << 1);\n  var digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  var dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  var k = <i32>dk;\n      k += i32(k != dk); // conversion with ceil\n\n  var index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = unchecked(FRC_POWERS[index]);\n  _exp_pow = unchecked(<i32>EXP_POWERS[index]);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32): i32 {\n\n  // frexp routine\n  var uv  = reinterpret<u64>(value);\n  var exp = <i32>((uv & 0x7FF0000000000000) >>> 52);\n  var sid = uv & 0x000FFFFFFFFFFFFF;\n  var frc = (u64(exp != 0) << 52) + sid;\n      exp = select<i32>(exp, 1, exp != 0) - (0x3FF + 52);\n\n  normalizedBoundaries(frc, exp);\n  getCachedPower(_exp);\n\n  // normalize\n  var off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  var frc_pow = _frc_pow;\n  var exp_pow = _exp_pow;\n\n  var w_frc = umul64f(frc, frc_pow);\n  var w_exp = umul64e(exp, exp_pow);\n\n  var wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  var wp_exp = umul64e(_exp,      exp_pow);\n\n  var wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  var delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  var one_exp = -mp_exp;\n  var one_frc = (<u64>1) << one_exp;\n  var mask    = one_frc - 1;\n\n  var wp_w_frc = mp_frc - w_frc;\n  var wp_w_exp = mp_exp;\n\n  var p1 = <u32>(mp_frc >> one_exp);\n  var p2 = mp_frc & mask;\n\n  var kappa = <i32>decimalCount32(p1);\n  var len = sign;\n\n  var lut = changetype<ArrayBufferView>(POWERS10).dataStart;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(lut + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (1) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(lut + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n\n  return len;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  var sign = k < 0;\n  if (sign) k = -k;\n  var decimals = decimalCount32(k) + 1;\n  utoa32_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  var kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nexport function dtoa_core(buffer: usize, value: f64): i32 {\n  var sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= 1.7976931348623157e308);\n  var len = grisu2(value, buffer, sign);\n      len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\nexport function dtoa(value: f64): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  var buffer = __alloc(MAX_DOUBLE_LENGTH << 1, idof<String>());\n  var length = dtoa_core(buffer, value);\n  if (length == MAX_DOUBLE_LENGTH) return changetype<String>(buffer);\n  var result = changetype<String>(buffer).substring(0, length);\n  __free(buffer);\n  return result;\n}\n\nexport function itoa_stream<T extends number>(buffer: usize, offset: usize, value: T): u32 {\n  buffer += (offset << 1);\n  if (!value) {\n    store<u16>(buffer, CharCode._0);\n    return 1;\n  }\n  var decimals: u32 = 0;\n  if (isSigned<T>()) {\n    let sign = i32(value < 0);\n    if (sign) value = changetype<T>(-value);\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value) + <u32>sign;\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32) + <u32>sign;\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value) + <u32>sign;\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n    if (sign) store<u16>(buffer, CharCode.MINUS);\n  } else {\n    if (sizeof<T>() <= 4) {\n      decimals = decimalCount32(value);\n      utoa32_core(buffer, value, decimals);\n    } else {\n      if (<u64>value <= <u64>u32.MAX_VALUE) {\n        let val32 = <u32>value;\n        decimals = decimalCount32(val32);\n        utoa32_core(buffer, val32, decimals);\n      } else {\n        decimals = decimalCount64(value);\n        utoa64_core(buffer, value, decimals);\n      }\n    }\n  }\n  return decimals;\n}\n\nexport function dtoa_stream(buffer: usize, offset: usize, value: f64): u32 {\n  buffer += (offset << 1);\n  if (value == 0.0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite<f64>(value)) {\n    if (isNaN<f64>(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = i32(value < 0);\n      let len  = 8 + sign;\n      memory.copy(buffer, changetype<usize>(select<String>(\"-Infinity\", \"Infinity\", sign)), len << 1);\n      return len;\n    }\n  }\n  return dtoa_core(buffer, value);\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { ArrayBuffer, ArrayBufferView } from \"./arraybuffer\";\nimport { itoa, dtoa, itoa_stream, dtoa_stream, MAX_DOUBLE_LENGTH } from \"./util/number\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureSize(array: usize, minSize: usize, alignLog2: u32): void {\n  var oldCapacity = changetype<ArrayBufferView>(array).dataLength;\n  if (minSize > oldCapacity >>> alignLog2) {\n    if (minSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).data);\n    let newCapacity = minSize << alignLog2;\n    let newData = __realloc(oldData, newCapacity);\n    memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    if (newData !== oldData) { // oldData has been free'd\n      store<usize>(changetype<usize>(array), __retain(newData), offsetof<ArrayBufferView>(\"data\"));\n      changetype<ArrayBufferView>(array).dataStart = newData;\n    }\n    changetype<ArrayBufferView>(array).dataLength = <u32>newCapacity;\n  }\n}\n\nexport class Array<T> extends ArrayBufferView {\n  [key: number]: T;\n\n  // Implementing ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `data`) and `dataLength` (equals computed `data.byteLength`).\n\n  // Also note that Array<T> with non-nullable T must guard against implicit null values whenever\n  // length is modified in a way that a null value would exist. Otherwise, the compiler wouldn't be\n  // able to guarantee type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return builtin_isArray(value) && value !== null;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    if (<u32>capacity > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    var array = changetype<Array<T>>(__allocArray(capacity, alignof<T>(), idof<T[]>())); // retains\n    changetype<Array<T>>(array).length_ = 0; // safe even if T is a non-nullable reference\n    memory.fill(array.dataStart, 0, <usize>array.dataLength);\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    super(length, alignof<T>());\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (length) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    this.length_ = length;\n  }\n\n  @unsafe get buffer(): ArrayBuffer {\n    return this.data;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    var oldLength = this.length_;\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (<u32>newLength > <u32>oldLength) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) { // release no longer used refs\n      if (oldLength > newLength) {\n        let dataStart = this.dataStart;\n        do __release(load<usize>(dataStart + (<usize>--oldLength << alignof<T>())));\n        while (oldLength > newLength);\n        // no need to zero memory on shrink -> is zeroed on grow\n      }\n    }\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (!fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(predicate: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (predicate(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return index;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (<u32>index >= <u32>this.length_) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    if (<u32>index >= <u32>this.dataLength >>> alignof<T>()) throw new RangeError(E_INDEXOUTOFRANGE);\n    return this.__unchecked_get(index);\n  }\n\n  @operator(\"{}\") private __unchecked_get(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    var length = this.length_;\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (<u32>index > <u32>length) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    ensureSize(changetype<usize>(this), index + 1, alignof<T>());\n    this.__unchecked_set(index, value);\n    if (index >= length) this.length_ = index + 1;\n  }\n\n  @operator(\"{}=\") private __unchecked_set(index: i32, value: T): void {\n    if (isManaged<T>()) {\n      let offset = this.dataStart + (<usize>index << alignof<T>());\n      let oldRef: usize = load<usize>(offset);\n      if (changetype<usize>(value) != oldRef) {\n        store<usize>(offset, __retain(changetype<usize>(value)));\n        __release(oldRef);\n      }\n    } else {\n      store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var length = this.length_;\n    start = start < 0 ? max(length + start, 0) : min(start, length);\n    end   = end   < 0 ? max(length + end,   0) : min(end,   length);\n    if (isManaged<T>()) {\n      for (; start < end; ++start) {\n        let oldRef: usize = load<usize>(dataStart + (<usize>start << alignof<T>()));\n        if (changetype<usize>(value) != oldRef) {\n          store<usize>(dataStart + (<usize>start << alignof<T>()), __retain(changetype<usize>(value)));\n          __release(oldRef);\n        }\n      }\n    } else if (sizeof<T>() == 1) {\n      if (start < end) {\n        memory.fill(\n          dataStart + <usize>start,\n          u8(value),\n          <usize>(end - start)\n        );\n      }\n    } else {\n      for (; start < end; ++start) {\n        store<T>(dataStart + (<usize>start << alignof<T>()), value);\n      }\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    return this.indexOf(value, fromIndex) >= 0;\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    var length = this.length_;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    var dataStart = this.dataStart;\n    while (fromIndex < length) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    var length = this.length_;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    var dataStart = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(dataStart + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    var length = this.length_;\n    var newLength = length + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>length << alignof<T>()), __retain(changetype<usize>(value)));\n    } else {\n      store<T>(this.dataStart + (<usize>length << alignof<T>()), value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    var thisLen = this.length_;\n    var otherLen = select(0, other.length_, other === null);\n    var outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    var out = changetype<Array<T>>(__allocArray(outLen, alignof<T>(), idof<Array<T>>())); // retains\n    var outStart = out.dataStart;\n    var thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, __retain(ref));\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): this {\n    var dataStart = this.dataStart;\n    var len = this.length_;\n\n        end   = min<i32>(end, len);\n    var to    = target < 0 ? max(len + target, 0) : min(target, len);\n    var from  = start < 0 ? max(len + start, 0) : min(start, len);\n    var last  = end < 0 ? max(len + end, 0) : min(end, len);\n    var count = min(last - from, len - to);\n\n    if (isManaged<T>()) {\n      if (from < to && to < (from + count)) { // right to left\n        from += count - 1;\n        to   += count - 1;\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          --from, --to, --count;\n        }\n      } else { // left to right\n        while (count) {\n          let oldRef: usize = load<usize>(dataStart + (<usize>to << alignof<T>()));\n          let newRef: usize = load<usize>(dataStart + (<usize>from << alignof<T>()));\n          if (newRef != oldRef) {\n            store<usize>(dataStart + (<usize>to << alignof<T>()), __retain(newRef));\n            __release(oldRef);\n          }\n          ++from, ++to, --count;\n        }\n      }\n    } else {\n      memory.copy( // is memmove\n        dataStart + (<usize>to << alignof<T>()),\n        dataStart + (<usize>from << alignof<T>()),\n        <usize>count << alignof<T>()\n      );\n    }\n    return this;\n  }\n\n  pop(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var element = load<T>(this.dataStart + (<usize>(--length) << alignof<T>()));\n    this.length_ = length;\n    return element; // no need to retain -> is moved\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    var length = this.length_;\n    var out = changetype<Array<U>>(__allocArray(length, alignof<U>(), idof<Array<U>>())); // retains\n    var outStart = out.dataStart;\n    for (let index = 0; index < min(length, this.length_); ++index) {\n      let result = fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this); // retains\n      if (isManaged<U>()) {\n        store<usize>(outStart + (<usize>index << alignof<U>()), __retain(changetype<usize>(result)));\n      } else {\n        store<U>(outStart + (<usize>index << alignof<U>()), result);\n      }\n      // releases result\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    var result = changetype<Array<T>>(__allocArray(0, alignof<T>(), idof<Array<T>>())); // retains\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n      if (fn(value, index, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    var accum = initialValue;\n    for (let index = this.length_ - 1; index >= 0; --index) {\n      accum = fn(accum, load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this);\n    }\n    return accum;\n  }\n\n  shift(): T {\n    var length = this.length_;\n    if (length < 1) throw new RangeError(E_EMPTYARRAY);\n    var base = this.dataStart;\n    var element = load<T>(base);\n    var lastIndex = length - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    store<T>(base + (<usize>lastIndex << alignof<T>()),\n      // @ts-ignore: cast\n      <T>null\n    );\n    this.length_ = lastIndex;\n    return element; // no need to retain -> is moved\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let index = 0, length = this.length_; index < min(length, this.length_); ++index) {\n      if (fn(load<T>(this.dataStart + (<usize>index << alignof<T>())), index, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    var newLength = this.length_ + 1;\n    ensureSize(changetype<usize>(this), newLength, alignof<T>());\n    var dataStart = this.dataStart;\n    memory.copy(\n      dataStart + sizeof<T>(),\n      dataStart,\n      <usize>(newLength - 1) << alignof<T>()\n    );\n    if (isManaged<T>()) {\n      store<usize>(dataStart, __retain(changetype<usize>(value)));\n    } else {\n      store<T>(dataStart, value);\n    }\n    this.length_ = newLength;\n    return newLength;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    var length = this.length_;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end  , length);\n    length = max(end - start, 0);\n    var slice = changetype<Array<T>>(__allocArray(length, alignof<T>(), idof<Array<T>>())); // retains\n    var sliceBase = slice.dataStart;\n    var thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>length << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, __retain(ref));\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, length << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    var length  = this.length_;\n    start       = start < 0 ? max<i32>(length + start, 0) : min<i32>(start, length);\n    deleteCount = max<i32>(min<i32>(deleteCount, length - start), 0);\n    var result = changetype<Array<T>>(__allocArray(deleteCount, alignof<T>(), idof<Array<T>>())); // retains\n    var resultStart = result.dataStart;\n    var thisStart = this.dataStart;\n    var thisBase  = thisStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      for (let i = 0; i < deleteCount; ++i) {\n        store<usize>(resultStart + (<usize>i << alignof<T>()),\n          load<usize>(thisBase + (<usize>i << alignof<T>()))\n        );\n        // no need to retain -> is moved\n      }\n    } else {\n      memory.copy(\n        resultStart,\n        thisBase,\n        <usize>deleteCount << alignof<T>()\n      );\n    }\n    var offset = start + deleteCount;\n    if (length != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(length - offset) << alignof<T>()\n      );\n    }\n    this.length_ = length - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    var length = this.length_;\n    if (length) {\n      let front = this.dataStart;\n      let back = this.dataStart + (<usize>(length - 1) << alignof<T>());\n      while (front < back) {\n        let temp = load<T>(front);\n        store<T>(front, load<T>(back));\n        store<T>(back, temp);\n        front += sizeof<T>();\n        back -= sizeof<T>();\n      }\n    }\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): this {\n    var length = this.length_;\n    if (length <= 1) return this;\n    var base = this.dataStart;\n    if (length == 2) {\n      let a: T = load<T>(base, sizeof<T>()); // a = arr[1]\n      let b: T = load<T>(base); // b = arr[0]\n      if (comparator(a, b) < 0) {\n        store<T>(base, b, sizeof<T>()); // arr[1] = b;\n        store<T>(base, a); // arr[0] = a;\n      }\n      return this;\n    }\n    SORT<T>(base, length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>()) return this.join_bool(separator);\n    if (isInteger<T>()) return this.join_int(separator);\n    if (isFloat<T>()) return this.join_flt(separator);\n    if (isString<T>()) return this.join_str(separator);\n    if (isArray<T>()) return this.join_arr(separator);\n    if (isReference<T>()) return this.join_ref(separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  private join_bool(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n    var sepLen = separator.length;\n    var valueLen = 5; // max possible length of element len(\"false\")\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n    var offset = 0;\n    var value: bool;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<bool>(dataStart + i);\n      valueLen = 4 + i32(!value);\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(select(\"true\", \"false\", value)),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<bool>(dataStart + <usize>lastIndex);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      valueLen << 1\n    );\n    offset += valueLen;\n\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  private join_int(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    // @ts-ignore: type\n    if (!lastIndex) return changetype<string>(itoa<T>(load<T>(dataStart))); // retains\n\n    var sepLen = separator.length;\n    const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n    var offset = 0;\n    var value: T;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(dataStart + (<usize>i << alignof<T>()));\n      // @ts-ignore: type\n      offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_stream<T>(changetype<usize>(result), offset, value);\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  private join_flt(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    if (!lastIndex) {\n      return changetype<string>(dtoa(\n        // @ts-ignore: type\n        load<T>(dataStart))\n      ); // retains\n    }\n\n    const valueLen = MAX_DOUBLE_LENGTH;\n    var sepLen = separator.length;\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>())); // retains\n    var offset = 0;\n    var value: T;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(dataStart + (<usize>i << alignof<T>()));\n      offset += dtoa_stream(changetype<usize>(result), offset,\n        // @ts-ignore: type\n        value\n      );\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n    offset += dtoa_stream(changetype<usize>(result), offset,\n      // @ts-ignore: type\n      value\n    );\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  private join_str(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var dataStart = this.dataStart;\n    if (!lastIndex) return load<string>(dataStart);\n\n    var sepLen = separator.length;\n    var estLen = 0;\n    var value: string | null;\n    for (let i = 0, len = lastIndex + 1; i < len; ++i) {\n      value = load<string>(dataStart + (<usize>i << alignof<T>()));\n      if (value !== null) estLen += value.length;\n    }\n    var offset = 0;\n    var result = changetype<string>(__alloc((estLen + sepLen * lastIndex) << 1, idof<string>())); // retains\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<string>(dataStart + (<usize>i << alignof<T>()));\n      if (value !== null) {\n        let valueLen = changetype<string>(value).length;\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(value),\n          <usize>valueLen << 1\n        );\n        offset += valueLen;\n      }\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    value = load<string>(dataStart + (<usize>lastIndex << alignof<T>()));\n    if (value !== null) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>changetype<string>(value).length << 1\n      );\n    }\n    return result;\n  }\n\n  private join_arr(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n\n    var result = \"\";\n    var sepLen = separator.length;\n    var base = this.dataStart;\n    var value: T;\n    if (!lastIndex) {\n      value = load<T>(base);\n      // @ts-ignore: type\n      return value ? value.join(separator) : \"\";\n    }\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(base + (<usize>i << alignof<T>()));\n      // @ts-ignore: type\n      if (value) result += value.join(separator);\n      if (sepLen) result += separator;\n    }\n    value = load<T>(base + (<usize>lastIndex << alignof<T>()));\n    // @ts-ignore: type\n    if (value) result += value.join(separator);\n    return result; // registered by concatenation (FIXME: lots of garbage)\n  }\n\n  private join_ref(separator: string = \",\"): string {\n    var lastIndex = this.length_ - 1;\n    if (lastIndex < 0) return \"\";\n    var base = this.dataStart;\n    if (!lastIndex) return \"[object Object]\";\n\n    const valueLen = 15; // max possible length of element len(\"[object Object]\")\n    var sepLen = separator.length;\n    var estLen = (valueLen + sepLen) * lastIndex + valueLen;\n    var result = changetype<string>(__alloc(estLen << 1, idof<string>()));\n    var offset = 0;\n    var value: T;\n    for (let i = 0; i < lastIndex; ++i) {\n      value = load<T>(base + (<usize>i << alignof<T>()));\n      if (value) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(\"[object Object]\"),\n          <usize>valueLen << 1\n        );\n        offset += valueLen;\n      }\n      if (sepLen) {\n        memory.copy(\n          changetype<usize>(result) + (<usize>offset << 1),\n          changetype<usize>(separator),\n          <usize>sepLen << 1\n        );\n        offset += sepLen;\n      }\n    }\n    if (load<T>(base + (<usize>lastIndex << alignof<T>()))) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(\"[object Object]\"),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (estLen > offset) return result.substring(0, offset);\n    return result;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit_impl(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    // automatically visits ArrayBufferView (.data) next\n  }\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { BLOCK, BLOCK_OVERHEAD } from \"./rt/common\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  var ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __instanceof(ref: usize, superId: u32): bool { // keyword\n  var id = changetype<BLOCK>(ref - BLOCK_OVERHEAD).rtId;\n  var ptr = __rtti_base;\n  if (id <= load<u32>(ptr)) {\n    do if (id == superId) return true;\n    while (id = changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).base);\n  }\n  return false;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __allocArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  var array = __alloc(offsetof<i32[]>(), id);\n  var bufferSize = <usize>length << alignLog2;\n  var buffer = __alloc(bufferSize, idof<ArrayBuffer>());\n  store<usize>(array, __retain(buffer), offsetof<ArrayBufferView>(\"data\"));\n  changetype<ArrayBufferView>(array).dataStart = buffer;\n  changetype<ArrayBufferView>(array).dataLength = bufferSize;\n  store<i32>(changetype<usize>(array), length, offsetof<i32[]>(\"length_\"));\n  if (data) memory.copy(buffer, data, bufferSize);\n  return array;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// @builtin @unsafe\n// export declare function __alloc(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ref: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __retain(ref: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __release(ref: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ref: usize, cookie: u32): void;\n",null,"import { itoa, dtoa } from \"./util/number\";\nimport { strtol } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0;\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0;\n\nexport function isNaN<T extends number>(value: T): bool {\n  if (!isFloat<T>()) {\n    if (!isInteger<T>()) ERROR(\"numeric type expected\");\n  }\n  return value != value;\n}\n\nexport function isFinite<T extends number>(value: T): bool {\n  if (!isFloat<T>()) {\n    if (!isInteger<T>()) ERROR(\"numeric type expected\");\n  }\n  return value - value == 0;\n}\n\n@sealed @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize): String {\n    // TODO: radix\n    return itoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool): String {\n    // TODO: radix?\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@sealed @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<i64>(value, radix);\n  }\n\n  static parseFloat(value: string): f32 {\n    return <f32>parseFloat(value);\n  }\n\n  toString(this: f32): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\n@sealed @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return <f64>strtol<i64>(value, radix);\n  }\n\n  static parseFloat(value: string): f64 {\n    return parseFloat(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    // TODO: radix\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: void): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): boolean;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(offset: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(offset: usize, value: void, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: void): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(target: void, ...args: void[]): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_direct<T>(target: void, ...args: void[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: void[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(offset: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(offset: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: void): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: void): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: void): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(offset: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(offset: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(offset: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(offset: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(offset: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(offset: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(offset: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i32, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(offset: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(offset: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: void): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(offset: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(offset: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(offset: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(offset: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function wait(ptr: usize, expected: i64, timeout: i64): AtomicWaitResult;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(offset: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(offset: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: void): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: void): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: void): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: void): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: void): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: void): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: void): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: void): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(offset: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: void): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(offset: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(offset: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(offset: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128; // except i64\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_saturate_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_s_f32x4_sat(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_u_f32x4_sat(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_s_f64x2_sat(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_u_f64x2_sat(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_s_i32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_u_i32x4(a: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_s_i64x2(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_u_i64x2(a: v128): v128;\n}\n\nexport namespace v8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n}\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n"]}